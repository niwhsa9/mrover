#version 450 core

// One invocation of "main" per pixel in the image
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform mat4 clipToCamera;
uniform ivec2 resolution;
uniform layout(binding = 0) sampler2D rgbImage;
uniform layout(binding = 1) sampler2D depthImage;

// An array of points is eventually copied to CPU memory
// As such it must follow the layout defined in "point.hpp"
struct Point {
    float x, y, z;
    float rgb; // 3 rgb bytes packed into a 32-bit float
    float nx, ny, nz;
    float curvature;
};

layout (std430, binding = 2) writeonly buffer Cloud {
    Point points[];
} cloud;

// Take in a normalized (i.e. each component is in [0, 1]) vec4, convert values to bytes, and pack into a float
float pack(vec4 rgba) {
    int r = int(rgba.r * 255.0);
    int g = int(rgba.g * 255.0);
    int b = int(rgba.b * 255.0);
    int a = 255; // a = alpha means fully opaque
    // TODO(quintin): Sort out WHY this is the correct shifting
    return intBitsToFloat((a << 24) | (r << 16) | (g << 8) | b);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    // I find it offensive that imageLoad ALWAYS returns vec4 despite the format of the underlying image...
    // For the color image, it converts rgba bytes to 0-1 floats
    // For the depth image, it populates the first element of the vec4
    float depth = texelFetch(depthImage, pixel, 0).r;
    float rgb = pack(texelFetch(rgbImage, pixel, 0));

    vec4 pointInClip = vec4(
        2.0 * (float(pixel.x) / float(resolution.x)) - 1.0,
        2.0 * (float(pixel.y) / float(resolution.y)) - 1.0,
        2.0 * depth - 1.0,
        1.0
    );
    vec4 pointInCamera = clipToCamera * pointInClip;
    pointInCamera /= pointInCamera.w;

    int flatIndex = (resolution.y - pixel.y) * resolution.x + pixel.x;
    cloud.points[flatIndex] = Point(
        pointInCamera.x,
        pointInCamera.y,
        pointInCamera.z,
        rgb,
        // TODO(quintin): Add normals for cost mapping (and perhaps curvature?)
        0.0,
        0.0,
        0.0,
        0.0
    );
}
